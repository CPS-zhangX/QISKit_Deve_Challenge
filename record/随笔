代价的主要来源：badCNOT
次要来源：使用H门来变方向

调整id的目的：
1、调整后可执行
2、调整后使用的swap减少
3、调整后使用的变相减少
4、无q使其直接连通-->调整为有q使其直接连通
更新：
1.完全消灭badCNOT
2.尽量减少badCNOT：解空间树遍历到最深的情况
3.减少badCNOT中的interQ的个数
4.减少使用H门进行变量的操作



执行步骤：
1、不用任何变化
2、仅cnot方向问题-->直接调整id，减少添加H门
3、有不可处理的cnot：调整4目的+swap门（1.尽量使用直接允许的cnot门  2.不用再交换回来）
4、减少相同的门reduceSameGate
5、2和3会生成idmap，用这个生成最终的QASM代码


要保证态存放的对应的经典比特是对的，否则即使过程正确，因为没有存放在指定的经典比特也会为错

如果idMap为
{2:1,4:2,1:0,0:4}
则变化的时候这样变化， 但是在测量的时候应该反过来
这样理解：原来的量子比特2现在实际上是1，所以原来量子比特2存放在2，所以现在应该由量子比特1存在2

两种调整量子比特ID的字典：
idMap：全局调整，天生的，在开始的时候就调整
partMap：部分调整，通过swap来调整

纠正一个badCNOT，在不考虑对后面影响的情况下：
cost = 34 * len(interQ)

思考：
找到interQ之后是cq去换还是tq去换，这是对整体有影响的：
出现的cnot：[[0, 1], [1, 0], [0, 1], [2, 3], [3, 2], [2, 3], [1, 2], [2, 1], [1, 2], [0, 4], [4, 0], [0, 4], [3, 0], [0, 3], [3, 0], [1, 2], [2, 1], [1, 2], [2, 4], [4, 2], [2, 4], [0, 1], [1, 0], [0, 1], [1, 2], [2, 1], [1, 2], [3, 0], [0, 3], [3, 0]]
coupling：{1: [0], 2: [3, 1], 3: [4], 0: [4]}
------------------------
[4]----此处是将0和4互换了，但如果将3和4互换则后续不需要在换
[[3, 4], [4, 3], [3, 4], [1, 2], [2, 1], [1, 2], [2, 0], [0, 2], [2, 0], [4, 1], [1, 4], [4, 1], [1, 2], [2, 1], [1, 2], [3, 4], [4, 3], [3, 4]]
[[2, 0], [4, 1]]
------------------------
[1]
[[2, 1], [1, 2], [2, 1], [4, 0], [0, 4], [4, 0], [0, 2], [2, 0], [0, 2], [3, 4], [4, 3], [3, 4]]
[[0, 2]]
------------------------
[1]
[[0, 1], [1, 0], [0, 1], [3, 4], [4, 3], [3, 4]]
[]



对于interQ这个列表，[1,2,3]，则cq-3-2-1-tq


    u3(theta, phi, lambda)
       = u3(theta1, phi1, lambda1).u3(theta2, phi2, lambda2)
       = Rz(phi1).Ry(theta1).Rz(lambda1+phi2).Ry(theta2).Rz(lambda2)
       = Rz(phi1).Rz(phi').Ry(theta').Rz(lambda').Rz(lambda2)
       = u3(theta', phi1 + phi', lambda2 + lambda')

5-21：
整体优化：图论？减少中间量子比特的总数
部分优化：是让cq去换还是tq去换
单量子比特的合成